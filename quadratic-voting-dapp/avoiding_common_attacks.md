# Avoiding Common Attacks
This is a discussion of a few common smart contract attacks how this contract attempts to mitigate them.

## Recursive Calls and Re-entrancy
I have avoided all external contract calls with the exception of the transfer() function. When the transfer function is used, all essential logic, with the exception of return statements, are completed before the transfer(). Additionally, the transfer() function is never used in a situation where an out-of-gas exception from the receiving address's fallback function would impact the logic of the QuadraticVoting contract (i.e. no looping over payment lists, etc.). If the transfer function fails, the voter's commitment has already been deleted and can not be revealed again. The major contract logic has also been limited to the QuadraticVoting.sol contract. While this makes for a long contract, it allows cross-contract calls to be avoided and prevents any confusion with multiple inheritance.

## Integer Arithmetic Overflow
The SafeMath library is used in all arithmetic operations to mitigate the risk of integer overflow. This will cause any integer overflows to revert before wrapping around. While this could potentially "break" the contract if certain uint-s (such as the pollCount) overflow, the advantage is that the contract would break in a predictable way, instead of failing in a way that could make it exploitable. Additionally, any crucial values such as pollCount are stored as uint256. Values susceptible to cheap overflow attacks were determined to be any value that can be directly entered by a user (such as when making a poll), or any value that is stored in a small enough integer to make overflowing it at a reasonable gas cost possible. These integers were identified and tested for overflow in ./test/quadraticVoting.js.

## Poison Data
All inputs tot the contract are directly limited by the input data type and require() statements on inputs such as election times. All string-like inputs are stored as bytes32 to predictably limit storage sizes of poll descriptions and candidate names.

## Miner vulnerabilities
While the system does rely heavily on timing to change the phase of polls, block.timestamp is not expected to be precise within 10-15 minutes, and there is no critical reliance on an exact value of block.timestamp. I worked to prevent race conditions and provided no incentive to commit or reveal votes before others. However, there is some advantage to committing a vote as late as possible because any committed funds would be unavailable to the voter for less time if votes were committed towards the end of the voting period. While this does not directly threaten the security of the contract, it is something that I will keep in mind in the future as it has the potential to influence close elections.

## Malicious Creator
All funds from votes that are committed but not revealed are transferred to the respective poll's charity address after the completion of the election. In theory, this means the contract should not be holding user's funds. The sweepBalance() function is a major vulnerability in the event of a malicious owner. This function is currently included to avoid any unforeseen issues with funds getting "stuck" in the contract. The future plan is to replace this with a default charity address. If a poll creator does not specify a charity address of funds become stuck in the contract for any other reason, the sweepBalance() function will transfer those funds to the default charity rather than to the contract owner.
